{
  "author": "https://github.com/FlokiTV",
  "description": "Create virtual joystick for touch \n\nScrene Variables for joystick - JOY is name of your joystick\n\nJOY_ANGLE - Angle of analog\nJOY_PRESS - Numbler of directions (1 or 2 for diagonals)\nJOY_DIR - Direction of joystick string\nJOY_DIS - Distance of joystick from center\nJOY_T - Return if is on TOP - Boolean\nJOY_D - Return if is on DOWN - Boolean\nJOY_R - Return if is on RIGHT - Boolean\nJOY_L - Return if is on LEFT - Boolean",
  "extensionNamespace": "",
  "fullName": "ðŸ•¹ Nipple",
  "helpPath": "https://github.com/FlokiTV/GDevelop-Nipple",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPg0KCS5zdDB7ZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPHBhdGggZD0iTTIxLDdjMC0yLjgtMi4yLTUtNS01cy01LDIuMi01LDVjMCwxLjYsMC44LDMuMSwyLDR2MTBjMCwwLjMsMC4xLDAuNSwwLjMsMC43YzAuNywwLjcsMS43LDEuMSwyLjcsMS4xczItMC40LDIuNy0xLjENCgljMC4yLTAuMiwwLjMtMC40LDAuMy0wLjdWMTFDMjAuMiwxMC4xLDIxLDguNiwyMSw3eiIvPg0KPHBhdGggZD0iTTI5LjgsMjMuNGwtMy40LTQuMmMwLDAsMCwwLDAsMEMyNS44LDE4LjQsMjUsMTgsMjQsMThoLTN2M2MwLDAuOC0wLjMsMS42LTAuOSwyLjFjLTEuMSwxLjEtMi42LDEuNy00LjEsMS43DQoJcy0zLTAuNi00LjEtMS43QzExLjMsMjIuNiwxMSwyMS44LDExLDIxdi0zSDhjLTAuOSwwLTEuOCwwLjQtMi4zLDEuMWwtMy40LDQuMkMyLjEsMjMuNiwyLDIzLjgsMiwyNHYzYzAsMS43LDEuMywzLDMsM2gyMg0KCWMxLjcsMCwzLTEuMywzLTN2LTNDMzAsMjMuOCwyOS45LDIzLjYsMjkuOCwyMy40eiIvPg0KPC9zdmc+DQo=",
  "name": "Nipple",
  "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/Glyphster Pack/Master/SVG/Videogames/Videogames_gamer_joystick_controller.svg",
  "shortDescription": "A virtual joystick for touch capable interfaces",
  "version": "beta 0.0.1",
  "tags": [
    "joystick",
    "analog"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "description": "",
      "fullName": "",
      "functionType": "Action",
      "name": "onFirstSceneLoaded",
      "private": false,
      "sentence": "",
      "events": [
        {
          "disabled": false,
          "folded": false,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "inverted": false,
                "value": "DepartScene"
              },
              "parameters": [
                ""
              ],
              "subInstructions": []
            },
            {
              "type": {
                "inverted": false,
                "value": "BuiltinCommonInstructions::Once"
              },
              "parameters": [],
              "subInstructions": []
            }
          ],
          "actions": [],
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "(function(f) {\n    if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n        module.exports = f()\n    } else if (typeof define === \"function\" && define.amd) {\n        define([], f)\n    } else {\n        var g;\n        if (typeof window !== \"undefined\") {\n            g = window\n        } else if (typeof global !== \"undefined\") {\n            g = global\n        } else if (typeof self !== \"undefined\") {\n            g = self\n        } else {\n            g = this\n        }\n        g.nipplejs = f()\n    }\n})(function() {\n    var define, module, exports;\n    'use strict';\n    // Constants\n    var isTouch = !!('ontouchstart' in window);\n    var isPointer = window.PointerEvent ? true : false;\n    var isMSPointer = window.MSPointerEvent ? true : false;\n    var events = {\n        touch: {\n            start: 'touchstart',\n            move: 'touchmove',\n            end: 'touchend, touchcancel'\n        },\n        mouse: {\n            start: 'mousedown',\n            move: 'mousemove',\n            end: 'mouseup'\n        },\n        pointer: {\n            start: 'pointerdown',\n            move: 'pointermove',\n            end: 'pointerup, pointercancel'\n        },\n        MSPointer: {\n            start: 'MSPointerDown',\n            move: 'MSPointerMove',\n            end: 'MSPointerUp'\n        }\n    };\n    var toBind;\n    var secondBind = {};\n    if (isPointer) {\n        toBind = events.pointer;\n    } else if (isMSPointer) {\n        toBind = events.MSPointer;\n    } else if (isTouch) {\n        toBind = events.touch;\n        secondBind = events.mouse;\n    } else {\n        toBind = events.mouse;\n    }\n    ///////////////////////\n    ///      UTILS      ///\n    ///////////////////////\n    var u = {};\n    u.distance = function(p1, p2) {\n        var dx = p2.x - p1.x;\n        var dy = p2.y - p1.y;\n        return Math.sqrt((dx * dx) + (dy * dy));\n    };\n    u.angle = function(p1, p2) {\n        var dx = p2.x - p1.x;\n        var dy = p2.y - p1.y;\n        return u.degrees(Math.atan2(dy, dx));\n    };\n    u.findCoord = function(p, d, a) {\n        var b = {\n            x: 0,\n            y: 0\n        };\n        a = u.radians(a);\n        b.x = p.x - d * Math.cos(a);\n        b.y = p.y - d * Math.sin(a);\n        return b;\n    };\n    u.radians = function(a) {\n        return a * (Math.PI / 180);\n    };\n    u.degrees = function(a) {\n        return a * (180 / Math.PI);\n    };\n    u.bindEvt = function(el, arg, handler) {\n        var types = arg.split(/[ ,]+/g);\n        var type;\n        for (var i = 0; i < types.length; i += 1) {\n            type = types[i];\n            if (el.addEventListener) {\n                el.addEventListener(type, handler, false);\n            } else if (el.attachEvent) {\n                el.attachEvent(type, handler);\n            }\n        }\n    };\n    u.unbindEvt = function(el, arg, handler) {\n        var types = arg.split(/[ ,]+/g);\n        var type;\n        for (var i = 0; i < types.length; i += 1) {\n            type = types[i];\n            if (el.removeEventListener) {\n                el.removeEventListener(type, handler);\n            } else if (el.detachEvent) {\n                el.detachEvent(type, handler);\n            }\n        }\n    };\n    u.trigger = function(el, type, data) {\n        var evt = new CustomEvent(type, data);\n        el.dispatchEvent(evt);\n    };\n    u.prepareEvent = function(evt) {\n        evt.preventDefault();\n        return evt.type.match(/^touch/) ? evt.changedTouches : evt;\n    };\n    u.getScroll = function() {\n        var x = (window.pageXOffset !== undefined) ?\n            window.pageXOffset :\n            (document.documentElement || document.body.parentNode || document.body)\n            .scrollLeft;\n        var y = (window.pageYOffset !== undefined) ?\n            window.pageYOffset :\n            (document.documentElement || document.body.parentNode || document.body)\n            .scrollTop;\n        return {\n            x: x,\n            y: y\n        };\n    };\n    u.applyPosition = function(el, pos) {\n        if (pos.top || pos.right || pos.bottom || pos.left) {\n            el.style.top = pos.top;\n            el.style.right = pos.right;\n            el.style.bottom = pos.bottom;\n            el.style.left = pos.left;\n        } else {\n            el.style.left = pos.x + 'px';\n            el.style.top = pos.y + 'px';\n        }\n    };\n    u.getTransitionStyle = function(property, values, time) {\n        var obj = u.configStylePropertyObject(property);\n        for (var i in obj) {\n            if (obj.hasOwnProperty(i)) {\n                if (typeof values === 'string') {\n                    obj[i] = values + ' ' + time;\n                } else {\n                    var st = '';\n                    for (var j = 0, max = values.length; j < max; j += 1) {\n                        st += values[j] + ' ' + time + ', ';\n                    }\n                    obj[i] = st.slice(0, -2);\n                }\n            }\n        }\n        return obj;\n    };\n    u.getVendorStyle = function(property, value) {\n        var obj = u.configStylePropertyObject(property);\n        for (var i in obj) {\n            if (obj.hasOwnProperty(i)) {\n                obj[i] = value;\n            }\n        }\n        return obj;\n    };\n    u.configStylePropertyObject = function(prop) {\n        var obj = {};\n        obj[prop] = '';\n        var vendors = ['webkit', 'Moz', 'o'];\n        vendors.forEach(function(vendor) {\n            obj[vendor + prop.charAt(0).toUpperCase() + prop.slice(1)] = '';\n        });\n        return obj;\n    };\n    u.extend = function(objA, objB) {\n        for (var i in objB) {\n            if (objB.hasOwnProperty(i)) {\n                objA[i] = objB[i];\n            }\n        }\n        return objA;\n    };\n    // Overwrite only what's already present\n    u.safeExtend = function(objA, objB) {\n        var obj = {};\n        for (var i in objA) {\n            if (objA.hasOwnProperty(i) && objB.hasOwnProperty(i)) {\n                obj[i] = objB[i];\n            } else if (objA.hasOwnProperty(i)) {\n                obj[i] = objA[i];\n            }\n        }\n        return obj;\n    };\n    // Map for array or unique item.\n    u.map = function(ar, fn) {\n        if (ar.length) {\n            for (var i = 0, max = ar.length; i < max; i += 1) {\n                fn(ar[i]);\n            }\n        } else {\n            fn(ar);\n        }\n    };\n    ///////////////////////\n    ///   SUPER CLASS   ///\n    ///////////////////////\n    function Super() {};\n    // Basic event system.\n    Super.prototype.on = function(arg, cb) {\n        var self = this;\n        var types = arg.split(/[ ,]+/g);\n        var type;\n        self._handlers_ = self._handlers_ || {};\n        for (var i = 0; i < types.length; i += 1) {\n            type = types[i];\n            self._handlers_[type] = self._handlers_[type] || [];\n            self._handlers_[type].push(cb);\n        }\n        return self;\n    };\n    Super.prototype.off = function(type, cb) {\n        var self = this;\n        self._handlers_ = self._handlers_ || {};\n        if (type === undefined) {\n            self._handlers_ = {};\n        } else if (cb === undefined) {\n            self._handlers_[type] = null;\n        } else if (self._handlers_[type] &&\n            self._handlers_[type].indexOf(cb) >= 0) {\n            self._handlers_[type].splice(self._handlers_[type].indexOf(cb), 1);\n        }\n        return self;\n    };\n    Super.prototype.trigger = function(arg, data) {\n        var self = this;\n        var types = arg.split(/[ ,]+/g);\n        var type;\n        self._handlers_ = self._handlers_ || {};\n        for (var i = 0; i < types.length; i += 1) {\n            type = types[i];\n            if (self._handlers_[type] && self._handlers_[type].length) {\n                self._handlers_[type].forEach(function(handler) {\n                    handler.call(self, {\n                        type: type,\n                        target: self\n                    }, data);\n                });\n            }\n        }\n    };\n    // Configuration\n    Super.prototype.config = function(options) {\n        var self = this;\n        self.options = self.defaults || {};\n        if (options) {\n            self.options = u.safeExtend(self.options, options);\n        }\n    };\n    // Bind internal events.\n    Super.prototype.bindEvt = function(el, type) {\n        var self = this;\n        self._domHandlers_ = self._domHandlers_ || {};\n        self._domHandlers_[type] = function() {\n            if (typeof self['on' + type] === 'function') {\n                self['on' + type].apply(self, arguments);\n            } else {\n                console.warn('[WARNING] : Missing \"on' + type + '\" handler.');\n            }\n        };\n        u.bindEvt(el, toBind[type], self._domHandlers_[type]);\n        if (secondBind[type]) {\n            // Support for both touch and mouse at the same time.\n            u.bindEvt(el, secondBind[type], self._domHandlers_[type]);\n        }\n        return self;\n    };\n    // Unbind dom events.\n    Super.prototype.unbindEvt = function(el, type) {\n        var self = this;\n        self._domHandlers_ = self._domHandlers_ || {};\n        u.unbindEvt(el, toBind[type], self._domHandlers_[type]);\n        if (secondBind[type]) {\n            // Support for both touch and mouse at the same time.\n            u.unbindEvt(el, secondBind[type], self._domHandlers_[type]);\n        }\n        delete self._domHandlers_[type];\n        return this;\n    };\n    ///////////////////////\n    ///   THE NIPPLE    ///\n    ///////////////////////\n    function Nipple(collection, options) {\n        this.identifier = options.identifier;\n        this.position = options.position;\n        this.frontPosition = options.frontPosition;\n        this.collection = collection;\n        // Defaults\n        this.defaults = {\n            size: 100,\n            threshold: 0.1,\n            color: 'white',\n            fadeTime: 250,\n            dataOnly: false,\n            restJoystick: true,\n            restOpacity: 0.5,\n            mode: 'dynamic',\n            zone: document.body,\n            lockX: false,\n            lockY: false\n        };\n        this.config(options);\n        // Overwrites\n        if (this.options.mode === 'dynamic') {\n            this.options.restOpacity = 0;\n        }\n        this.id = Nipple.id;\n        Nipple.id += 1;\n        this.buildEl()\n            .stylize();\n        // Nipple's API.\n        this.instance = {\n            el: this.ui.el,\n            on: this.on.bind(this),\n            off: this.off.bind(this),\n            show: this.show.bind(this),\n            hide: this.hide.bind(this),\n            add: this.addToDom.bind(this),\n            remove: this.removeFromDom.bind(this),\n            destroy: this.destroy.bind(this),\n            resetDirection: this.resetDirection.bind(this),\n            computeDirection: this.computeDirection.bind(this),\n            trigger: this.trigger.bind(this),\n            position: this.position,\n            frontPosition: this.frontPosition,\n            ui: this.ui,\n            identifier: this.identifier,\n            id: this.id,\n            options: this.options\n        };\n        return this.instance;\n    };\n    Nipple.prototype = new Super();\n    Nipple.constructor = Nipple;\n    Nipple.id = 0;\n    // Build the dom element of the Nipple instance.\n    Nipple.prototype.buildEl = function(options) {\n        this.ui = {};\n        if (this.options.dataOnly) {\n            return this;\n        }\n        this.ui.el = document.createElement('div');\n        this.ui.back = document.createElement('div');\n        this.ui.front = document.createElement('div');\n        this.ui.el.className = 'nipple collection_' + this.collection.id;\n        this.ui.back.className = 'back';\n        this.ui.front.className = 'front';\n        this.ui.el.setAttribute('id', 'nipple_' + this.collection.id +\n            '_' + this.id);\n        this.ui.el.appendChild(this.ui.back);\n        this.ui.el.appendChild(this.ui.front);\n        return this;\n    };\n    // Apply CSS to the Nipple instance.\n    Nipple.prototype.stylize = function() {\n        if (this.options.dataOnly) {\n            return this;\n        }\n        var animTime = this.options.fadeTime + 'ms';\n        var borderStyle = u.getVendorStyle('borderRadius', '50%');\n        var transitStyle = u.getTransitionStyle('transition', 'opacity', animTime);\n        var styles = {};\n        styles.el = {\n            position: 'absolute',\n            opacity: this.options.restOpacity,\n            display: 'block',\n            'zIndex': 999\n        };\n        styles.back = {\n            position: 'absolute',\n            display: 'block',\n            width: this.options.size + 'px',\n            height: this.options.size + 'px',\n            marginLeft: -this.options.size / 2 + 'px',\n            marginTop: -this.options.size / 2 + 'px',\n            background: this.options.color,\n            'opacity': '.5'\n        };\n        styles.front = {\n            width: this.options.size / 2 + 'px',\n            height: this.options.size / 2 + 'px',\n            position: 'absolute',\n            display: 'block',\n            marginLeft: -this.options.size / 4 + 'px',\n            marginTop: -this.options.size / 4 + 'px',\n            background: this.options.color,\n            'opacity': '.5'\n        };\n        u.extend(styles.el, transitStyle);\n        u.extend(styles.back, borderStyle);\n        u.extend(styles.front, borderStyle);\n        this.applyStyles(styles);\n        return this;\n    };\n    Nipple.prototype.applyStyles = function(styles) {\n        // Apply styles\n        for (var i in this.ui) {\n            if (this.ui.hasOwnProperty(i)) {\n                for (var j in styles[i]) {\n                    this.ui[i].style[j] = styles[i][j];\n                }\n            }\n        }\n        return this;\n    };\n    // Inject the Nipple instance into DOM.\n    Nipple.prototype.addToDom = function() {\n        // We're not adding it if we're dataOnly or already in dom.\n        if (this.options.dataOnly || document.body.contains(this.ui.el)) {\n            return this;\n        }\n        this.options.zone.appendChild(this.ui.el);\n        return this;\n    };\n    // Remove the Nipple instance from DOM.\n    Nipple.prototype.removeFromDom = function() {\n        if (this.options.dataOnly || !document.body.contains(this.ui.el)) {\n            return this;\n        }\n        this.options.zone.removeChild(this.ui.el);\n        return this;\n    };\n    // Entirely destroy this nipple\n    Nipple.prototype.destroy = function() {\n        clearTimeout(this.removeTimeout);\n        clearTimeout(this.showTimeout);\n        clearTimeout(this.restTimeout);\n        this.trigger('destroyed', this.instance);\n        this.removeFromDom();\n        this.off();\n    };\n    // Fade in the Nipple instance.\n    Nipple.prototype.show = function(cb) {\n        var self = this;\n        if (self.options.dataOnly) {\n            return self;\n        }\n        clearTimeout(self.removeTimeout);\n        clearTimeout(self.showTimeout);\n        clearTimeout(self.restTimeout);\n        self.addToDom();\n        self.restCallback();\n        setTimeout(function() {\n            self.ui.el.style.opacity = 1;\n        }, 0);\n        self.showTimeout = setTimeout(function() {\n            self.trigger('shown', self.instance);\n            if (typeof cb === 'function') {\n                cb.call(this);\n            }\n        }, self.options.fadeTime);\n        return self;\n    };\n    // Fade out the Nipple instance.\n    Nipple.prototype.hide = function(cb) {\n        var self = this;\n        if (self.options.dataOnly) {\n            return self;\n        }\n        self.ui.el.style.opacity = self.options.restOpacity;\n        clearTimeout(self.removeTimeout);\n        clearTimeout(self.showTimeout);\n        clearTimeout(self.restTimeout);\n        self.removeTimeout = setTimeout(\n            function() {\n                var display = self.options.mode === 'dynamic' ? 'none' : 'block';\n                self.ui.el.style.display = display;\n                if (typeof cb === 'function') {\n                    cb.call(self);\n                }\n                self.trigger('hidden', self.instance);\n            },\n            self.options.fadeTime\n        );\n        if (self.options.restJoystick) {\n            self.restPosition();\n        }\n        return self;\n    };\n    Nipple.prototype.restPosition = function(cb) {\n        var self = this;\n        self.frontPosition = {\n            x: 0,\n            y: 0\n        };\n        var animTime = self.options.fadeTime + 'ms';\n        var transitStyle = {};\n        transitStyle.front = u.getTransitionStyle('transition',\n            ['top', 'left'], animTime);\n        var styles = {\n            front: {}\n        };\n        styles.front = {\n            left: self.frontPosition.x + 'px',\n            top: self.frontPosition.y + 'px'\n        };\n        self.applyStyles(transitStyle);\n        self.applyStyles(styles);\n        self.restTimeout = setTimeout(\n            function() {\n                if (typeof cb === 'function') {\n                    cb.call(self);\n                }\n                self.restCallback();\n            },\n            self.options.fadeTime\n        );\n    };\n    Nipple.prototype.restCallback = function() {\n        var self = this;\n        var transitStyle = {};\n        transitStyle.front = u.getTransitionStyle('transition', 'none', '');\n        self.applyStyles(transitStyle);\n        self.trigger('rested', self.instance);\n    };\n    Nipple.prototype.resetDirection = function() {\n        // Fully rebuild the object to let the iteration possible.\n        this.direction = {\n            x: false,\n            y: false,\n            angle: false\n        };\n    };\n    Nipple.prototype.computeDirection = function(obj) {\n        var rAngle = obj.angle.radian;\n        var angle45 = Math.PI / 4;\n        var angle90 = Math.PI / 2;\n        var direction, directionX, directionY;\n        // Angular direction\n        //     \\  UP /\n        //      \\   /\n        // LEFT       RIGHT\n        //      /   \\\n        //     /DOWN \\\n        //\n        if (\n            rAngle > angle45 &&\n            rAngle < (angle45 * 3) &&\n            !obj.lockX\n        ) {\n            direction = 'up';\n        } else if (\n            rAngle > -angle45 &&\n            rAngle <= angle45 &&\n            !obj.lockY\n        ) {\n            direction = 'left';\n        } else if (\n            rAngle > (-angle45 * 3) &&\n            rAngle <= -angle45 &&\n            !obj.lockX\n        ) {\n            direction = 'down';\n        } else if (!obj.lockY) {\n            direction = 'right';\n        }\n        // Plain direction\n        //    UP                 |\n        // _______               | RIGHT\n        //                  LEFT |\n        //   DOWN                |\n        if (!obj.lockY) {\n            if (rAngle > -angle90 && rAngle < angle90) {\n                directionX = 'left';\n            } else {\n                directionX = 'right';\n            }\n        }\n        if (!obj.lockX) {\n            if (rAngle > 0) {\n                directionY = 'up';\n            } else {\n                directionY = 'down';\n            }\n        }\n        if (obj.force > this.options.threshold) {\n            var oldDirection = {};\n            for (var i in this.direction) {\n                if (this.direction.hasOwnProperty(i)) {\n                    oldDirection[i] = this.direction[i];\n                }\n            }\n            var same = {};\n            this.direction = {\n                x: directionX,\n                y: directionY,\n                angle: direction\n            };\n            obj.direction = this.direction;\n            for (var i in oldDirection) {\n                if (oldDirection[i] === this.direction[i]) {\n                    same[i] = true;\n                }\n            }\n            // If all 3 directions are the same, we don't trigger anything.\n            if (same.x && same.y && same.angle) {\n                return obj;\n            }\n            if (!same.x || !same.y) {\n                this.trigger('plain', obj);\n            }\n            if (!same.x) {\n                this.trigger('plain:' + directionX, obj);\n            }\n            if (!same.y) {\n                this.trigger('plain:' + directionY, obj);\n            }\n            if (!same.angle) {\n                this.trigger('dir dir:' + direction, obj);\n            }\n        }\n        return obj;\n    };\n    /* global Nipple, Super */\n    ///////////////////////////\n    ///   THE COLLECTION    ///\n    ///////////////////////////\n    function Collection(manager, options) {\n        var self = this;\n        self.nipples = [];\n        self.idles = [];\n        self.actives = [];\n        self.ids = [];\n        self.pressureIntervals = {};\n        self.manager = manager;\n        self.id = Collection.id;\n        Collection.id += 1;\n        // Defaults\n        self.defaults = {\n            zone: document.body,\n            multitouch: false,\n            maxNumberOfNipples: 10,\n            mode: 'dynamic',\n            position: {\n                top: 0,\n                left: 0\n            },\n            catchDistance: 200,\n            size: 100,\n            threshold: 0.1,\n            color: 'white',\n            fadeTime: 250,\n            dataOnly: false,\n            restJoystick: true,\n            restOpacity: 0.5,\n            lockX: false,\n            lockY: false\n        };\n        self.config(options);\n        // Overwrites\n        if (self.options.mode === 'static' || self.options.mode === 'semi') {\n            self.options.multitouch = false;\n        }\n        if (!self.options.multitouch) {\n            self.options.maxNumberOfNipples = 1;\n        }\n        self.updateBox();\n        self.prepareNipples();\n        self.bindings();\n        self.begin();\n        return self.nipples;\n    }\n    Collection.prototype = new Super();\n    Collection.constructor = Collection;\n    Collection.id = 0;\n    Collection.prototype.prepareNipples = function() {\n        var self = this;\n        var nips = self.nipples;\n        // Public API Preparation.\n        nips.on = self.on.bind(self);\n        nips.off = self.off.bind(self);\n        nips.options = self.options;\n        nips.destroy = self.destroy.bind(self);\n        nips.ids = self.ids;\n        nips.id = self.id;\n        nips.processOnMove = self.processOnMove.bind(self);\n        nips.processOnEnd = self.processOnEnd.bind(self);\n        nips.get = function(id) {\n            if (id === undefined) {\n                return nips[0];\n            }\n            for (var i = 0, max = nips.length; i < max; i += 1) {\n                if (nips[i].identifier === id) {\n                    return nips[i];\n                }\n            }\n            return false;\n        };\n    };\n    Collection.prototype.bindings = function() {\n        var self = this;\n        // Touch start event.\n        self.bindEvt(self.options.zone, 'start');\n        // Avoid native touch actions (scroll, zoom etc...) on the zone.\n        self.options.zone.style.touchAction = 'none';\n        self.options.zone.style.msTouchAction = 'none';\n    };\n    Collection.prototype.begin = function() {\n        var self = this;\n        var opts = self.options;\n        // We place our static nipple\n        // if needed.\n        if (opts.mode === 'static') {\n            var nipple = self.createNipple(\n                opts.position,\n                self.manager.getIdentifier()\n            );\n            // Add it to the dom.\n            nipple.add();\n            // Store it in idles.\n            self.idles.push(nipple);\n        }\n    };\n    // Nipple Factory\n    Collection.prototype.createNipple = function(position, identifier) {\n        var self = this;\n        var scroll = u.getScroll();\n        var toPutOn = {};\n        var opts = self.options;\n        if (position.x && position.y) {\n            toPutOn = {\n                x: position.x -\n                    (scroll.x + self.box.left),\n                y: position.y -\n                    (scroll.y + self.box.top)\n            };\n        } else if (\n            position.top ||\n            position.right ||\n            position.bottom ||\n            position.left\n        ) {\n            // We need to compute the position X / Y of the joystick.\n            var dumb = document.createElement('DIV');\n            dumb.style.display = 'hidden';\n            dumb.style.top = position.top;\n            dumb.style.right = position.right;\n            dumb.style.bottom = position.bottom;\n            dumb.style.left = position.left;\n            dumb.style.position = 'absolute';\n            opts.zone.appendChild(dumb);\n            var dumbBox = dumb.getBoundingClientRect();\n            opts.zone.removeChild(dumb);\n            toPutOn = position;\n            position = {\n                x: dumbBox.left + scroll.x,\n                y: dumbBox.top + scroll.y\n            };\n        }\n        var nipple = new Nipple(self, {\n            color: opts.color,\n            size: opts.size,\n            threshold: opts.threshold,\n            fadeTime: opts.fadeTime,\n            dataOnly: opts.dataOnly,\n            restJoystick: opts.restJoystick,\n            restOpacity: opts.restOpacity,\n            mode: opts.mode,\n            identifier: identifier,\n            position: position,\n            zone: opts.zone,\n            frontPosition: {\n                x: 0,\n                y: 0\n            }\n        });\n        if (!opts.dataOnly) {\n            u.applyPosition(nipple.ui.el, toPutOn);\n            u.applyPosition(nipple.ui.front, nipple.frontPosition);\n        }\n        self.nipples.push(nipple);\n        self.trigger('added ' + nipple.identifier + ':added', nipple);\n        self.manager.trigger('added ' + nipple.identifier + ':added', nipple);\n        self.bindNipple(nipple);\n        return nipple;\n    };\n    Collection.prototype.updateBox = function() {\n        var self = this;\n        self.box = self.options.zone.getBoundingClientRect();\n    };\n    Collection.prototype.bindNipple = function(nipple) {\n        var self = this;\n        var type;\n        // Bubble up identified events.\n        var handler = function(evt, data) {\n            // Identify the event type with the nipple's id.\n            type = evt.type + ' ' + data.id + ':' + evt.type;\n            self.trigger(type, data);\n        };\n        // When it gets destroyed.\n        nipple.on('destroyed', self.onDestroyed.bind(self));\n        // Other events that will get bubbled up.\n        nipple.on('shown hidden rested dir plain', handler);\n        nipple.on('dir:up dir:right dir:down dir:left', handler);\n        nipple.on('plain:up plain:right plain:down plain:left', handler);\n    };\n    Collection.prototype.pressureFn = function(touch, nipple, identifier) {\n        var self = this;\n        var previousPressure = 0;\n        clearInterval(self.pressureIntervals[identifier]);\n        // Create an interval that will read the pressure every 100ms\n        self.pressureIntervals[identifier] = setInterval(function() {\n            var pressure = touch.force || touch.pressure ||\n                touch.webkitForce || 0;\n            if (pressure !== previousPressure) {\n                nipple.trigger('pressure', pressure);\n                self.trigger('pressure ' +\n                    nipple.identifier + ':pressure', pressure);\n                previousPressure = pressure;\n            }\n        }.bind(self), 100);\n    };\n    Collection.prototype.onstart = function(evt) {\n        var self = this;\n        var opts = self.options;\n        evt = u.prepareEvent(evt);\n        // Update the box position\n        self.updateBox();\n        var process = function(touch) {\n            // If we can create new nipples\n            // meaning we don't have more active nipples than we should.\n            if (self.actives.length < opts.maxNumberOfNipples) {\n                self.processOnStart(touch);\n            }\n        };\n        u.map(evt, process);\n        // We ask upstream to bind the document\n        // on 'move' and 'end'\n        self.manager.bindDocument();\n        return false;\n    };\n    Collection.prototype.processOnStart = function(evt) {\n        var self = this;\n        var opts = self.options;\n        var indexInIdles;\n        var identifier = self.manager.getIdentifier(evt);\n        var pressure = evt.force || evt.pressure || evt.webkitForce || 0;\n        var position = {\n            x: evt.pageX,\n            y: evt.pageY\n        };\n        var nipple = self.getOrCreate(identifier, position);\n        // Update its touch identifier\n        if (nipple.identifier !== identifier) {\n            self.manager.removeIdentifier(nipple.identifier);\n        }\n        nipple.identifier = identifier;\n        var process = function(nip) {\n            // Trigger the start.\n            nip.trigger('start', nip);\n            self.trigger('start ' + nip.id + ':start', nip);\n            nip.show();\n            if (pressure > 0) {\n                self.pressureFn(evt, nip, nip.identifier);\n            }\n            // Trigger the first move event.\n            self.processOnMove(evt);\n        };\n        // Transfer it from idles to actives.\n        if ((indexInIdles = self.idles.indexOf(nipple)) >= 0) {\n            self.idles.splice(indexInIdles, 1);\n        }\n        // Store the nipple in the actives array\n        self.actives.push(nipple);\n        self.ids.push(nipple.identifier);\n        if (opts.mode !== 'semi') {\n            process(nipple);\n        } else {\n            // In semi we check the distance of the touch\n            // to decide if we have to reset the nipple\n            var distance = u.distance(position, nipple.position);\n            if (distance <= opts.catchDistance) {\n                process(nipple);\n            } else {\n                nipple.destroy();\n                self.processOnStart(evt);\n                return;\n            }\n        }\n        return nipple;\n    };\n    Collection.prototype.getOrCreate = function(identifier, position) {\n        var self = this;\n        var opts = self.options;\n        var nipple;\n        // If we're in static or semi, we might already have an active.\n        if (/(semi|static)/.test(opts.mode)) {\n            // Get the active one.\n            // TODO: Multi-touche for semi and static will start here.\n            // Return the nearest one.\n            nipple = self.idles[0];\n            if (nipple) {\n                self.idles.splice(0, 1);\n                return nipple;\n            }\n            if (opts.mode === 'semi') {\n                // If we're in semi mode, we need to create one.\n                return self.createNipple(position, identifier);\n            }\n            console.warn('Coudln\\'t find the needed nipple.');\n            return false;\n        }\n        // In dynamic, we create a new one.\n        nipple = self.createNipple(position, identifier);\n        return nipple;\n    };\n    Collection.prototype.processOnMove = function(evt) {\n        var self = this;\n        var opts = self.options;\n        var identifier = self.manager.getIdentifier(evt);\n        var nipple = self.nipples.get(identifier);\n        if (!nipple) {\n            // This is here just for safety.\n            // It shouldn't happen.\n            console.error('Found zombie joystick with ID ' + identifier);\n            self.manager.removeIdentifier(identifier);\n            return;\n        }\n        nipple.identifier = identifier;\n        var size = nipple.options.size / 2;\n        var pos = {\n            x: evt.pageX,\n            y: evt.pageY\n        };\n        var dist = u.distance(pos, nipple.position);\n        var angle = u.angle(pos, nipple.position);\n        var rAngle = u.radians(angle);\n        var force = dist / size;\n        // If distance is bigger than nipple's size\n        // we clamp the position.\n        if (dist > size) {\n            dist = size;\n            pos = u.findCoord(nipple.position, dist, angle);\n        }\n        var xPosition = pos.x - nipple.position.x\n        var yPosition = pos.y - nipple.position.y\n        if (opts.lockX) {\n            yPosition = 0\n        }\n        if (opts.lockY) {\n            xPosition = 0\n        }\n        nipple.frontPosition = {\n            x: xPosition,\n            y: yPosition\n        };\n        if (!opts.dataOnly) {\n            u.applyPosition(nipple.ui.front, nipple.frontPosition);\n        }\n        // Prepare event's datas.\n        var toSend = {\n            identifier: nipple.identifier,\n            position: pos,\n            force: force,\n            pressure: evt.force || evt.pressure || evt.webkitForce || 0,\n            distance: dist,\n            angle: {\n                radian: rAngle,\n                degree: angle\n            },\n            instance: nipple,\n            lockX: opts.lockX,\n            lockY: opts.lockY\n        };\n        // Compute the direction's datas.\n        toSend = nipple.computeDirection(toSend);\n        // Offset angles to follow units circle.\n        toSend.angle = {\n            radian: u.radians(180 - angle),\n            degree: 180 - angle\n        };\n        // Send everything to everyone.\n        nipple.trigger('move', toSend);\n        self.trigger('move ' + nipple.id + ':move', toSend);\n    };\n    Collection.prototype.processOnEnd = function(evt) {\n        var self = this;\n        var opts = self.options;\n        var identifier = self.manager.getIdentifier(evt);\n        var nipple = self.nipples.get(identifier);\n        var removedIdentifier = self.manager.removeIdentifier(nipple.identifier);\n        if (!nipple) {\n            return;\n        }\n        if (!opts.dataOnly) {\n            nipple.hide(function() {\n                if (opts.mode === 'dynamic') {\n                    nipple.trigger('removed', nipple);\n                    self.trigger('removed ' + nipple.id + ':removed', nipple);\n                    self.manager\n                        .trigger('removed ' + nipple.id + ':removed', nipple);\n                    nipple.destroy();\n                }\n            });\n        }\n        // Clear the pressure interval reader\n        clearInterval(self.pressureIntervals[nipple.identifier]);\n        // Reset the direciton of the nipple, to be able to trigger a new direction\n        // on start.\n        nipple.resetDirection();\n        nipple.trigger('end', nipple);\n        self.trigger('end ' + nipple.id + ':end', nipple);\n        // Remove identifier from our bank.\n        if (self.ids.indexOf(nipple.identifier) >= 0) {\n            self.ids.splice(self.ids.indexOf(nipple.identifier), 1);\n        }\n        // Clean our actives array.\n        if (self.actives.indexOf(nipple) >= 0) {\n            self.actives.splice(self.actives.indexOf(nipple), 1);\n        }\n        if (/(semi|static)/.test(opts.mode)) {\n            // Transfer nipple from actives to idles\n            // if we're in semi or static mode.\n            self.idles.push(nipple);\n        } else if (self.nipples.indexOf(nipple) >= 0) {\n            // Only if we're not in semi or static mode\n            // we can remove the instance.\n            self.nipples.splice(self.nipples.indexOf(nipple), 1);\n        }\n        // We unbind move and end.\n        self.manager.unbindDocument();\n        // We add back the identifier of the idle nipple;\n        if (/(semi|static)/.test(opts.mode)) {\n            self.manager.ids[removedIdentifier.id] = removedIdentifier.identifier;\n        }\n    };\n    // Remove destroyed nipple from the lists\n    Collection.prototype.onDestroyed = function(evt, nipple) {\n        var self = this;\n        if (self.nipples.indexOf(nipple) >= 0) {\n            self.nipples.splice(self.nipples.indexOf(nipple), 1);\n        }\n        if (self.actives.indexOf(nipple) >= 0) {\n            self.actives.splice(self.actives.indexOf(nipple), 1);\n        }\n        if (self.idles.indexOf(nipple) >= 0) {\n            self.idles.splice(self.idles.indexOf(nipple), 1);\n        }\n        if (self.ids.indexOf(nipple.identifier) >= 0) {\n            self.ids.splice(self.ids.indexOf(nipple.identifier), 1);\n        }\n        // Remove the identifier from our bank\n        self.manager.removeIdentifier(nipple.identifier);\n        // We unbind move and end.\n        self.manager.unbindDocument();\n    };\n    // Cleanly destroy the manager\n    Collection.prototype.destroy = function() {\n        var self = this;\n        self.unbindEvt(self.options.zone, 'start');\n        // Destroy nipples.\n        self.nipples.forEach(function(nipple) {\n            nipple.destroy();\n        });\n        // Clean 3DTouch intervals.\n        for (var i in self.pressureIntervals) {\n            if (self.pressureIntervals.hasOwnProperty(i)) {\n                clearInterval(self.pressureIntervals[i]);\n            }\n        }\n        // Notify the manager passing the instance\n        self.trigger('destroyed', self.nipples);\n        // We unbind move and end.\n        self.manager.unbindDocument();\n        // Unbind everything.\n        self.off();\n    };\n    /* global u, Super, Collection */\n    ///////////////////////\n    ///     MANAGER     ///\n    ///////////////////////\n    function Manager(options) {\n        var self = this;\n        self.ids = {};\n        self.index = 0;\n        self.collections = [];\n        self.config(options);\n        self.prepareCollections();\n        // Listen for resize, to reposition every joysticks\n        var resizeTimer;\n        u.bindEvt(window, 'resize', function(evt) {\n            clearTimeout(resizeTimer);\n            resizeTimer = setTimeout(function() {\n                var pos;\n                var scroll = u.getScroll();\n                self.collections.forEach(function(collection) {\n                    collection.forEach(function(nipple) {\n                        pos = nipple.el.getBoundingClientRect();\n                        nipple.position = {\n                            x: scroll.x + pos.left,\n                            y: scroll.y + pos.top\n                        };\n                    });\n                });\n            }, 100);\n        });\n        return self.collections;\n    };\n    Manager.prototype = new Super();\n    Manager.constructor = Manager;\n    Manager.prototype.prepareCollections = function() {\n        var self = this;\n        // Public API Preparation.\n        self.collections.create = self.create.bind(self);\n        // Listen to anything\n        self.collections.on = self.on.bind(self);\n        // Unbind general events\n        self.collections.off = self.off.bind(self);\n        // Destroy everything\n        self.collections.destroy = self.destroy.bind(self);\n        // Get any nipple\n        self.collections.get = function(id) {\n            var nipple;\n            self.collections.every(function(collection) {\n                if (nipple = collection.get(id)) {\n                    return false;\n                }\n                return true;\n            });\n            return nipple;\n        };\n    };\n    Manager.prototype.create = function(options) {\n        return this.createCollection(options);\n    };\n    // Collection Factory\n    Manager.prototype.createCollection = function(options) {\n        var self = this;\n        var collection = new Collection(self, options);\n        self.bindCollection(collection);\n        self.collections.push(collection);\n        return collection;\n    };\n    Manager.prototype.bindCollection = function(collection) {\n        var self = this;\n        var type;\n        // Bubble up identified events.\n        var handler = function(evt, data) {\n            // Identify the event type with the nipple's identifier.\n            type = evt.type + ' ' + data.id + ':' + evt.type;\n            self.trigger(type, data);\n        };\n        // When it gets destroyed we clean.\n        collection.on('destroyed', self.onDestroyed.bind(self));\n        // Other events that will get bubbled up.\n        collection.on('shown hidden rested dir plain', handler);\n        collection.on('dir:up dir:right dir:down dir:left', handler);\n        collection.on('plain:up plain:right plain:down plain:left', handler);\n    };\n    Manager.prototype.bindDocument = function() {\n        var self = this;\n        // Bind only if not already binded\n        if (!self.binded) {\n            self.bindEvt(document, 'move')\n                .bindEvt(document, 'end');\n            self.binded = true;\n        }\n    };\n    Manager.prototype.unbindDocument = function(force) {\n        var self = this;\n        // If there are no touch left\n        // unbind the document.\n        if (!Object.keys(self.ids).length || force === true) {\n            self.unbindEvt(document, 'move')\n                .unbindEvt(document, 'end');\n            self.binded = false;\n        }\n    };\n    Manager.prototype.getIdentifier = function(evt) {\n        var id;\n        // If no event, simple increment\n        if (!evt) {\n            id = this.index;\n        } else {\n            // Extract identifier from event object.\n            // Unavailable in mouse events so replaced by latest increment.\n            id = evt.identifier === undefined ? evt.pointerId : evt.identifier;\n            if (id === undefined) {\n                id = this.latest || 0;\n            }\n        }\n        if (this.ids[id] === undefined) {\n            this.ids[id] = this.index;\n            this.index += 1;\n        }\n        // Keep the latest id used in case we're using an unidentified mouseEvent\n        this.latest = id;\n        return this.ids[id];\n    };\n    Manager.prototype.removeIdentifier = function(identifier) {\n        var removed = {};\n        for (var id in this.ids) {\n            if (this.ids[id] === identifier) {\n                removed.id = id;\n                removed.identifier = this.ids[id];\n                delete this.ids[id];\n                break;\n            }\n        }\n        return removed;\n    };\n    Manager.prototype.onmove = function(evt) {\n        var self = this;\n        self.onAny('move', evt);\n        return false;\n    };\n    Manager.prototype.onend = function(evt) {\n        var self = this;\n        self.onAny('end', evt);\n        return false;\n    };\n    Manager.prototype.oncancel = function(evt) {\n        var self = this;\n        self.onAny('end', evt);\n        return false;\n    };\n    Manager.prototype.onAny = function(which, evt) {\n        var self = this;\n        var id;\n        var processFn = 'processOn' + which.charAt(0).toUpperCase() +\n            which.slice(1);\n        evt = u.prepareEvent(evt);\n        var processColl = function(e, id, coll) {\n            if (coll.ids.indexOf(id) >= 0) {\n                coll[processFn](e);\n                // Mark the event to avoid cleaning it later.\n                e._found_ = true;\n            }\n        };\n        var processEvt = function(e) {\n            id = self.getIdentifier(e);\n            u.map(self.collections, processColl.bind(null, e, id));\n            // If the event isn't handled by any collection,\n            // we need to clean its identifier.\n            if (!e._found_) {\n                self.removeIdentifier(id);\n            }\n        };\n        u.map(evt, processEvt);\n        return false;\n    };\n    // Cleanly destroy the manager\n    Manager.prototype.destroy = function() {\n        var self = this;\n        self.unbindDocument(true);\n        self.ids = {};\n        self.index = 0;\n        self.collections.forEach(function(collection) {\n            collection.destroy();\n        });\n        self.off();\n    };\n    // When a collection gets destroyed\n    // we clean behind.\n    Manager.prototype.onDestroyed = function(evt, coll) {\n        var self = this;\n        if (self.collections.indexOf(coll) < 0) {\n            return false;\n        }\n        self.collections.splice(self.collections.indexOf(coll), 1);\n    };\n    var factory = new Manager();\n    return {\n        create: function(options) {\n            return factory.create(options);\n        },\n        factory: factory\n    };\n});\n\ngdjs._nipplejs  = nipplejs\ngdjs._nippleDir = ang =>{\n    if( ang > 337.5 ) return \"right\"\n    if( ang < 22.5 ) return \"right\"\n    if( ang < 337.5 && ang > 292.5 ) return \"right+down\"\n    if( ang < 292.5 && ang > 247.5 ) return \"down\"\n    if( ang < 247.5 && ang > 202.5 ) return \"left+down\"\n    if( ang < 202.5 && ang > 157.5 ) return \"left\"\n    if( ang < 157.5 && ang > 112.5 ) return \"left+top\"\n    if( ang < 112.5 && ang > 67.5 ) return \"top\"\n    if( ang < 67.5 && ang >  22.5 ) return \"top+right\"\n}",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ]
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Create virtual joystick",
      "fullName": "Create virtual joystick",
      "functionType": "Action",
      "name": "add",
      "private": false,
      "sentence": "Add nipple _PARAM1_ size _PARAM6_ on position X _PARAM2_ and Y _PARAM3_ - Width: _PARAM4_ Height _PARAM5_ Background _PARAM8_ Type _PARAM7_; Debug _PARAM9_",
      "events": [
        {
          "disabled": false,
          "folded": false,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "inverted": false,
                "value": "BuiltinCommonInstructions::Once"
              },
              "parameters": [],
              "subInstructions": []
            }
          ],
          "actions": [],
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "let APP_NAME = eventsFunctionContext.getArgument(\"Name\")\nlet TYPE     = eventsFunctionContext.getArgument(\"Type\")\nlet SIZE     = eventsFunctionContext.getArgument(\"Size\")\nlet DEBUG    = eventsFunctionContext.getArgument(\"Debug\")\nlet X = eventsFunctionContext.getArgument(\"X\")\nlet Y = eventsFunctionContext.getArgument(\"Y\")\nlet W = eventsFunctionContext.getArgument(\"W\")\nlet H = eventsFunctionContext.getArgument(\"H\")\nlet BG = eventsFunctionContext.getArgument(\"BG\").split(\";\").join(\",\")\nlet nipple   = document.createElement('div')\nnipple.id = `_joystick_${APP_NAME}`\n// nipple.setAttribute(\"style\", `\n//     position: absolute;\n//     width: ${W};\n//     height: ${H};\n//     left: ${X};\n//     top: ${Y};\n//     background: rgba(${BG}, 0${DEBUG ? '.05': ''});\n// `)\nnipple.style.position = \"absolute\"\nnipple.style.width = W\nnipple.style.height = H\nnipple.style.left = X\nnipple.style.top = Y\nnipple.style.background = `rgba(${BG}, 0${DEBUG ? '.05': ''})`\ndocument.querySelector('body').appendChild(nipple)\n\nvar options = {\n    zone: document.querySelector(`#_joystick_${APP_NAME}`),\n    mode: TYPE,\n    size: SIZE,\n    position: {\n      left: '50%',\n      top: '50%'\n    },\n    color: `rgba(${BG}, 1)`\n};\nvar manager = nipplejs.create(options);\nconst getDir = ang =>{\n    if( ang > 337.5 ) return \"right\"\n    if( ang < 22.5 ) return \"right\"\n    if( ang < 337.5 && ang > 292.5 ) return \"right+down\"\n    if( ang < 292.5 && ang > 247.5 ) return \"down\"\n    if( ang < 247.5 && ang > 202.5 ) return \"left+down\"\n    if( ang < 202.5 && ang > 157.5 ) return \"left\"\n    if( ang < 157.5 && ang > 112.5 ) return \"left+top\"\n    if( ang < 112.5 && ang > 67.5 ) return \"top\"\n    if( ang < 67.5 && ang >  22.5 ) return \"top+right\"\n    return ang\n}\nruntimeScene.getVariables().add(APP_NAME+\"_ANGLE\")\nruntimeScene.getVariables().add(APP_NAME+\"_PRESS\")\nruntimeScene.getVariables().add(APP_NAME+\"_DIR\")\nruntimeScene.getVariables().add(APP_NAME+\"_DIS\")\nruntimeScene.getVariables().add(APP_NAME+\"_T\")\nruntimeScene.getVariables().add(APP_NAME+\"_D\")\nruntimeScene.getVariables().add(APP_NAME+\"_R\")\nruntimeScene.getVariables().add(APP_NAME+\"_L\")\n\nmanager.on('move', (evt, data) =>{\n    let dir = getDir(data.angle.degree)\n    runtimeScene.getVariables().get(APP_NAME+\"_ANGLE\").setString(data.angle.degree)\n    runtimeScene.getVariables().get(APP_NAME+\"_DIR\").setString(dir)\n    runtimeScene.getVariables().get(APP_NAME+\"_DIS\").setValue(parseInt(data.distance))\n    runtimeScene.getVariables().get(APP_NAME+\"_PRESS\").setValue(dir.includes(\"+\") ? 2 : 1)\n    runtimeScene.getVariables().get(APP_NAME+\"_T\").setBoolean(dir.includes(\"top\")) \n    runtimeScene.getVariables().get(APP_NAME+\"_D\").setBoolean(dir.includes(\"down\")) \n    runtimeScene.getVariables().get(APP_NAME+\"_R\").setBoolean(dir.includes(\"right\")) \n    runtimeScene.getVariables().get(APP_NAME+\"_L\").setBoolean(dir.includes(\"left\")) \n})\n\nmanager.on('end', (evt, data) =>{\n    runtimeScene.getVariables().get(APP_NAME+\"_ANGLE\").setValue(0)\n    runtimeScene.getVariables().get(APP_NAME+\"_DIS\").setValue(0)\n    runtimeScene.getVariables().get(APP_NAME+\"_PRESS\").setValue(0)\n    runtimeScene.getVariables().get(APP_NAME+\"_T\").setBoolean(false) \n    runtimeScene.getVariables().get(APP_NAME+\"_D\").setBoolean(false) \n    runtimeScene.getVariables().get(APP_NAME+\"_R\").setBoolean(false) \n    runtimeScene.getVariables().get(APP_NAME+\"_L\").setBoolean(false) \n})\n",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ]
        }
      ],
      "parameters": [
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Joystick name",
          "longDescription": "",
          "name": "Name",
          "optional": false,
          "supplementaryInformation": "",
          "type": "string"
        },
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "X position (use px or % - this is a css position)",
          "longDescription": "",
          "name": "X",
          "optional": false,
          "supplementaryInformation": "",
          "type": "string"
        },
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Y position  (use px or % - this is a css position)",
          "longDescription": "",
          "name": "Y",
          "optional": false,
          "supplementaryInformation": "",
          "type": "string"
        },
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Container Width (use px or % - this is a css size)",
          "longDescription": "",
          "name": "W",
          "optional": false,
          "supplementaryInformation": "",
          "type": "string"
        },
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Container Height (use px or % - this is a css size)",
          "longDescription": "",
          "name": "H",
          "optional": false,
          "supplementaryInformation": "",
          "type": "string"
        },
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Joystick size",
          "longDescription": "",
          "name": "Size",
          "optional": false,
          "supplementaryInformation": "",
          "type": "expression"
        },
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Type of joystick (default: dynamic)",
          "longDescription": "",
          "name": "Type",
          "optional": false,
          "supplementaryInformation": "[\"dynamic\",\"semi\",\"static\"]",
          "type": "stringWithSelector"
        },
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Color",
          "longDescription": "",
          "name": "BG",
          "optional": false,
          "supplementaryInformation": "",
          "type": "color"
        },
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Debug",
          "longDescription": "",
          "name": "Debug",
          "optional": false,
          "supplementaryInformation": "",
          "type": "yesorno"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Remove joystick",
      "fullName": "Remove joystick",
      "functionType": "Action",
      "name": "remove",
      "private": false,
      "sentence": "Remove joystick _PARAM1_",
      "events": [
        {
          "disabled": false,
          "folded": false,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "inverted": false,
                "value": "BuiltinCommonInstructions::Once"
              },
              "parameters": [],
              "subInstructions": []
            },
            {
              "type": {
                "inverted": false,
                "value": "Nipple::exist"
              },
              "parameters": [
                "",
                "GetArgumentAsString(\"Name\")",
                ""
              ],
              "subInstructions": []
            }
          ],
          "actions": [],
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "let APP_NAME = eventsFunctionContext.getArgument(\"Name\")\ndocument.querySelector(`#_joystick_${APP_NAME}`).remove()",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Joystick name",
          "longDescription": "",
          "name": "Name",
          "optional": false,
          "supplementaryInformation": "",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set joystick position",
      "fullName": "Set joystick position",
      "functionType": "Action",
      "name": "setPosition",
      "private": false,
      "sentence": "Set joystick _PARAM1_ position _PARAM2_ ",
      "events": [
        {
          "disabled": false,
          "folded": false,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "inverted": false,
                "value": "Nipple::exist"
              },
              "parameters": [
                "",
                "GetArgumentAsString(\"Name\")",
                ""
              ],
              "subInstructions": []
            }
          ],
          "actions": [],
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "let APP_NAME = eventsFunctionContext.getArgument(\"Name\")\nlet POSITION = eventsFunctionContext.getArgument(\"Position\")\nlet EL = document.querySelector(`#_joystick_${APP_NAME}`)\n// document.querySelector(`#_joystick_${APP_NAME}`).style.display = \"block\"\nconsole.log(POSITION)\nswitch(POSITION){\n    case \"Top left\":\n        EL.style.top = 0\n        EL.style.left = 0\n    break\n    case \"Top center\":\n        EL.style.top = 0\n        EL.style.left = \"calc(50% - \"+EL.offsetWidth/2+\"px)\"\n    break\n    case \"Top right\":\n        EL.style.top = 0\n        EL.style.left = \"calc(100% - \"+EL.offsetWidth+\"px)\"\n    break\n    case \"Center left\":\n        EL.style.top = \"calc(50% - \"+EL.offsetHeight/2+\"px)\"\n        EL.style.left = 0\n    break\n    case \"Center center\":\n        EL.style.top = \"calc(50% - \"+EL.offsetHeight/2+\"px)\"\n        EL.style.left = \"calc(50% - \"+EL.offsetWidth/2+\"px)\"\n    break\n    case \"Center right\":\n        EL.style.top = \"calc(50% - \"+EL.offsetHeight/2+\"px)\"\n        EL.style.left = \"calc(100% - \"+EL.offsetWidth+\"px)\"\n    break\n    case \"Bottom left\":\n        EL.style.top = \"calc(100% - \"+EL.offsetWidth+\"px)\"\n        EL.style.left = 0\n    break\n    case \"Bottom center\":\n        EL.style.top = \"calc(100% - \"+EL.offsetWidth+\"px)\"\n        EL.style.left = \"calc(50% - \"+EL.offsetWidth/2+\"px)\"\n    break\n    case \"Bottom right\":\n        EL.style.top = \"calc(100% - \"+EL.offsetWidth+\"px)\"\n        EL.style.left = \"calc(100% - \"+EL.offsetHeight+\"px)\"\n    break\n}\n",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Joystick name",
          "longDescription": "",
          "name": "Name",
          "optional": false,
          "supplementaryInformation": "",
          "type": "string"
        },
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Position",
          "longDescription": "",
          "name": "Position",
          "optional": false,
          "supplementaryInformation": "[\"Top left\",\"Top center\",\"Top right\",\"Center left\",\"Center center\",\"Center right\",\"Bottom left\",\"Bottom center\",\"Bottom right\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Show joystick",
      "fullName": "Show joystick",
      "functionType": "Action",
      "name": "show",
      "private": false,
      "sentence": "Show joystick _PARAM1_",
      "events": [
        {
          "disabled": false,
          "folded": false,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "inverted": false,
                "value": "BuiltinCommonInstructions::Once"
              },
              "parameters": [],
              "subInstructions": []
            },
            {
              "type": {
                "inverted": false,
                "value": "Nipple::exist"
              },
              "parameters": [
                "",
                "GetArgumentAsString(\"Name\")",
                ""
              ],
              "subInstructions": []
            }
          ],
          "actions": [],
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "let APP_NAME = eventsFunctionContext.getArgument(\"Name\")\ndocument.querySelector(`#_joystick_${APP_NAME}`).style.display = \"block\"",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Joystick name",
          "longDescription": "",
          "name": "Name",
          "optional": false,
          "supplementaryInformation": "",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Hide joystick",
      "fullName": "Hide joystick",
      "functionType": "Action",
      "name": "hide",
      "private": false,
      "sentence": "Hide joystick _PARAM1_",
      "events": [
        {
          "disabled": false,
          "folded": false,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "inverted": false,
                "value": "BuiltinCommonInstructions::Once"
              },
              "parameters": [],
              "subInstructions": []
            },
            {
              "type": {
                "inverted": false,
                "value": "Nipple::exist"
              },
              "parameters": [
                "",
                "GetArgumentAsString(\"Name\")",
                ""
              ],
              "subInstructions": []
            }
          ],
          "actions": [],
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "let APP_NAME = eventsFunctionContext.getArgument(\"Name\")\ndocument.querySelector(`#_joystick_${APP_NAME}`).style.display = \"none\"",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Joystick name",
          "longDescription": "",
          "name": "Name",
          "optional": false,
          "supplementaryInformation": "",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check if joystick is hidden",
      "fullName": "Check if joystick is hidden",
      "functionType": "Condition",
      "name": "isHide",
      "private": false,
      "sentence": "Check if _PARAM1_ is hidden",
      "events": [
        {
          "disabled": false,
          "folded": false,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "inverted": false,
                "value": "Nipple::exist"
              },
              "parameters": [
                "",
                "GetArgumentAsString(\"Name\")",
                ""
              ],
              "subInstructions": []
            }
          ],
          "actions": [],
          "events": [
            {
              "disabled": false,
              "folded": false,
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "let APP_NAME = eventsFunctionContext.getArgument(\"Name\")\n\neventsFunctionContext.returnValue = document.querySelector(`#_joystick_${APP_NAME}`).style.display == \"none\" || false",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ]
        }
      ],
      "parameters": [
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Joystick name",
          "longDescription": "",
          "name": "Name",
          "optional": false,
          "supplementaryInformation": "",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check if joystick exist",
      "fullName": "Check if joystick exist",
      "functionType": "Condition",
      "name": "exist",
      "private": false,
      "sentence": "Check if _PARAM1_ exist",
      "events": [
        {
          "disabled": false,
          "folded": false,
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": "let APP_NAME = eventsFunctionContext.getArgument(\"Name\")\nlet check = document.querySelector(`#_joystick_${APP_NAME}`) || false\n\neventsFunctionContext.returnValue = check",
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Joystick name",
          "longDescription": "",
          "name": "Name",
          "optional": false,
          "supplementaryInformation": "",
          "type": "string"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": []
}